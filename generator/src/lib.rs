#![recursion_limit="256"]

extern crate syn;
extern crate syntex_syntax as syntax;
#[macro_use]
extern crate quote;
extern crate parser;

fn function_declarations(
    functions: &[parser::Function],
    uses: &[::quote::Tokens],
    library_name: &str) -> ::quote::Tokens {
    let extern_lua_ffi_c_header_functions = functions
        .iter()
        .map(|function|{
            let ident = function.ident.to_string();
            let mut argument_declaration: Vec<_> = function.args
                .iter()
                .map(|arg| {
                    let typ = &arg.typ;
                    quote! {
                        <#typ as ::lua_marshalling::Type>::c_function_argument()
                    }
                })
                .collect();
            let ret = &function.ret;
            argument_declaration.push(
                quote! {
                    format!("{}*", <#ret as ::lua_marshalling::Type>::c_mut_function_argument())
                }
            );
            quote! {
                format!(r#"int32_t {ident}(
    {argument_declaration});"#,
                    ident=#ident,
                    argument_declaration=[#(#argument_declaration),*].join(",\n    ")),
                format!("int32_t __gc_{ident}(
    {argument_declaration});",
                    ident=#ident,
                    argument_declaration=<#ret as ::lua_marshalling::Type>::c_mut_function_argument())
            }
        });

    let extern_lua_function_wrappers = functions
        .iter()
        .map(|function|{
            let ident = function.ident.to_string();
            let argument_declaration: Vec<_> = function.args
                .iter()
                .map(|arg| arg.ident.to_string())
                .collect();
            let argument_passing: Vec<_> = function.args
                .iter()
                .map(|arg| {
                    let ident = arg.ident.to_string();
                    let typ = &arg.typ;
                    quote!{
                        format!(
                            "invoke({ident}, {function})",
                            ident=#ident,
                            function=<#typ as ::lua_marshalling::IntoRawConversion>::function())
                    }
                })
                .collect();

            let ret = &function.ret;
            let argument_declaration = argument_declaration.join(",\n    ");

            quote!{
                format!(r#"function M.{ident}(
    {argument_declaration})
    local __typeof = __c_mut_function_argument_{typename}
    local __ret_ptr = __typeof(1, {{}})
    local status = rust.{ident}(
        {argument_passing}
    )
    if status ~= 0 then
        error("{ident} failed with status "..status)
    end
    local __ret = __ret_ptr[0]
    {gc}
    return invoke(__ret, {function})
end
"#,
                    ident = #ident,
                    argument_declaration = #argument_declaration,
                    typename = <#ret as ::lua_marshalling::Type>::typename(),
                    argument_passing = {
                        let mut argument_passing: Vec<String> = [#(#argument_passing),*].to_vec();
                        argument_passing.push("__ret_ptr".to_owned());
                        argument_passing
                    }.join(",\n    "),
                    gc = if <#ret as ::lua_marshalling::FromRawConversion>::gc() {
                        format!("ffi.gc(__ret, rust.__gc_{})", #ident)
                    } else {
                        "".to_owned()
                    },
                    function = <#ret as ::lua_marshalling::FromRawConversion>::function()
                )
            }
        });

    let extern_lua_unique_types = functions
        .iter()
        .map(|function|{
            let args = function.args
                .iter()
                .map(|arg| {
                    let typ = &arg.typ;
                    quote! {
                        ::lua_marshalling::make_dependencies::<#typ>()
                    }
                });

            let ret = &function.ret;
            quote! {
                #(#args,)*
                ::lua_marshalling::make_dependencies::<#ret>(),
            }
        });

    quote! {
        #[doc(hidden)]
        pub mod lua_bootstrap {
            #(use #uses;)*

            #[no_mangle]
            pub extern "C" fn __lua_bootstrap() -> *mut ::libc::c_char {
                let unique_types: ::lua_marshalling::Dependencies = [ #(#extern_lua_unique_types)* ]
                    .into_iter()
                    .flat_map(|value| value.into_iter()
                        .map(|(k, v)| (k.clone(), v.clone())))
                    .collect();
                let sorted_types =
                    ::lua_marshalling::dependency_sorted_type_descriptions(&unique_types);

                ::std::ffi::CString::new(
                    [
                        r#"-- Code generated by Rust Lua interface. DO NOT EDIT.

local ffi = require("ffi")

ffi.cdef[[
"#.to_owned(),
                        sorted_types
                            .iter()
                            .map(|dependencies| (dependencies.typedeclaration)())
                            .collect::<Vec<_>>()
                            .join("\n"),
                        {
                            let functions: Vec<String> = vec![#(#extern_lua_ffi_c_header_functions),*];
                            functions
                        }.join("\n"),
                        format!(r#"
]]

local rust = ffi.load("{library_name}")

function invoke(value, fn)
    return fn(value)
end

function readonlytable(table)
    return setmetatable({{}}, {{
        __index = table,
        __newindex = function(_, key, value)
            error("Attempt to modify read-only table")
        end,
        __len = function(_)
            return #table
        end,
        __ipairs = function(_)
            return ipairs(table)
        end,
        __pairs = function(_)
            return pairs(table)
        end,
        __metatable = false
    }});
end

local M = {{}}

"#, library_name = #library_name),
                        sorted_types
                            .iter()
                            .map(|dependencies| (dependencies.metatype)())
                            .collect::<Vec<String>>()
                            .join("\n"),
                        #(#extern_lua_function_wrappers,)*
                        r#"
return M
"#.to_owned()
                    ].join("\n"))
                        .ok()
                        .map(::std::ffi::CString::into_raw)
                        .unwrap_or_else(::std::ptr::null_mut)
            }

            #[no_mangle]
            pub unsafe extern "C" fn __free_lua_bootstrap(bootstrap: *mut ::libc::c_char) {
                if bootstrap != ::std::ptr::null_mut() {
                    ::std::ffi::CString::from_raw(bootstrap);
                }
            }
        }
    }
}

pub fn generate(input: &::std::path::Path, library_name: &str) -> String {
    let session = ::syntax::parse::ParseSess::new(::syntax::codemap::FilePathMapping::empty());
    let krate = ::syntax::parse::parse_crate_from_file(input, &session).unwrap();
    let items = parser::extern_ffi_mod(&krate).unwrap();
    let uses = parser::uses(items);
    let functions = parser::functions(items);

    format!("{}\n{}\n",
            parser::function_declarations(&functions, &uses).as_str(),
            function_declarations(&functions, &uses, library_name).as_str())
}
